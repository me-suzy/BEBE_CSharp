using System;
using System.IO;
using System.Text;
using Newtonsoft.Json;
using BebeTaskRecorder.Models;

namespace BebeTaskRecorder
{
    public class TaskExporter
    {
        public static void ExportAsJson(TaskData taskData, string filePath)
        {
            string json = JsonConvert.SerializeObject(taskData, Formatting.Indented);
            File.WriteAllText(filePath, json, Encoding.UTF8);

            // Also write a log file
            string logPath = Path.ChangeExtension(filePath, ".log");
            WriteLogFile(logPath, taskData);
        }

        public static TaskData ImportFromJson(string filePath)
        {
            string json = File.ReadAllText(filePath, Encoding.UTF8);
            return JsonConvert.DeserializeObject<TaskData>(json);
        }

        public static void ExportAsExecutable(TaskData taskData, string exePath)
        {
            // Strategy: Create a standalone C# executable with embedded JSON data
            // This is MUCH simpler than PyInstaller!
            
            string taskJson = JsonConvert.SerializeObject(taskData);
            string taskName = taskData.Name ?? Path.GetFileNameWithoutExtension(exePath);

            // Generate C# source code for the task runner
            string sourceCode = GenerateTaskRunnerSource(taskJson, taskName);

            // Save temporary C# file
            string tempDir = Path.Combine(Path.GetTempPath(), "BEBE_Build_" + Guid.NewGuid().ToString("N"));
            Directory.CreateDirectory(tempDir);

            try
            {
                string csFile = Path.Combine(tempDir, "TaskRunner.cs");
                File.WriteAllText(csFile, sourceCode, Encoding.UTF8);

                // Create .csproj for the runner
                string csprojContent = GenerateRunnerCsproj(taskName);
                string csprojFile = Path.Combine(tempDir, "TaskRunner.csproj");
                File.WriteAllText(csprojFile, csprojContent, Encoding.UTF8);

                // Build using dotnet CLI
                var process = new System.Diagnostics.Process
                {
                    StartInfo = new System.Diagnostics.ProcessStartInfo
                    {
                        FileName = "dotnet",
                        Arguments = $"publish -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -o \"{Path.GetDirectoryName(exePath)}\"",
                        WorkingDirectory = tempDir,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true
                    }
                };

                process.Start();
                string output = process.StandardOutput.ReadToEnd();
                string error = process.StandardError.ReadToEnd();
                process.WaitForExit();

                if (process.ExitCode != 0)
                {
                    throw new Exception($"Build failed:\n{error}\n{output}");
                }

                // Rename the output exe to the desired name
                string builtExe = Path.Combine(Path.GetDirectoryName(exePath), "TaskRunner.exe");
                if (File.Exists(exePath))
                    File.Delete(exePath);
                File.Move(builtExe, exePath);

                // Write log file
                string logPath = Path.ChangeExtension(exePath, ".log");
                WriteLogFile(logPath, taskData);
            }
            finally
            {
                // Cleanup temp directory
                try
                {
                    Directory.Delete(tempDir, true);
                }
                catch { }
            }
        }

        private static string GenerateTaskRunnerSource(string taskDataJson, string taskName)
        {
            // Convert JSON to Base64 to avoid escape issues
            byte[] jsonBytes = Encoding.UTF8.GetBytes(taskDataJson);
            string base64Json = Convert.ToBase64String(jsonBytes);

            return $@"
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Newtonsoft.Json;

// Task: {taskName}
// Generated by BEBE Task Recorder v3.0

public class Program
{{
    const string EMBEDDED_DATA_BASE64 = @""{base64Json}"";

    [STAThread]
    static void Main()
    {{
        try
        {{
            // Decode Base64 to JSON
            byte[] jsonBytes = Convert.FromBase64String(EMBEDDED_DATA_BASE64);
            string jsonData = System.Text.Encoding.UTF8.GetString(jsonBytes);
            var taskData = JsonConvert.DeserializeObject<TaskData>(jsonData);
            
            if (taskData == null || taskData.Events == null || taskData.Events.Count == 0)
            {{
                MessageBox.Show(""No events to execute."", ""{taskName}"", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }}

            // Check schedule
            if (!CheckSchedule(taskData.Schedule))
            {{
                MessageBox.Show(""Task is scheduled for a different time."", ""{taskName}"", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }}

            MessageBox.Show(""Task will start in 3 seconds. Press OK to continue."", ""{taskName}"", MessageBoxButtons.OK, MessageBoxIcon.Information);
            Thread.Sleep(3000);

            var player = new TaskPlayer();
            player.Play(taskData.Events, taskData.Playback);

            MessageBox.Show(""Task completed!"", ""{taskName}"", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }}
        catch (Exception ex)
        {{
            MessageBox.Show($""Error: {{ex.Message}}"", ""{taskName}"", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }}
    }}

    static bool CheckSchedule(ScheduleSettings schedule)
    {{
        if (schedule == null || !schedule.Enabled) return true;

        var now = DateTime.Now;
        string currentDay = now.DayOfWeek.ToString().ToLower();
        
        if (!schedule.Days.Contains(currentDay)) return false;

        TimeSpan start = TimeSpan.Parse(schedule.TimeFrom);
        TimeSpan end = TimeSpan.Parse(schedule.TimeTo);
        TimeSpan current = now.TimeOfDay;

        return current >= start && current <= end;
    }}
}}

// Models and Player classes embedded below

public class TaskData
{{
    public string Name {{ get; set; }}
    public string Version {{ get; set; }}
    public DateTime Created {{ get; set; }}
    public List<TaskEvent> Events {{ get; set; }}
    public PlaybackSettings Playback {{ get; set; }}
    public ScheduleSettings Schedule {{ get; set; }}
}}

public class TaskEvent
{{
    public string Type {{ get; set; }}
    public double Timestamp {{ get; set; }}
    public int X {{ get; set; }}
    public int Y {{ get; set; }}
    public string Button {{ get; set; }}
    public bool Pressed {{ get; set; }}
    public string Key {{ get; set; }}
    public int Dx {{ get; set; }}
    public int Dy {{ get; set; }}
}}

public class PlaybackSettings
{{
    public double Speed {{ get; set; }}
    public bool Loop {{ get; set; }}
    public bool RunUntilStop {{ get; set; }}
}}

public class ScheduleSettings
{{
    public bool Enabled {{ get; set; }}
    public List<string> Days {{ get; set; }}
    public string TimeFrom {{ get; set; }}
    public string TimeTo {{ get; set; }}
}}

public class TaskPlayer
{{
    [DllImport(""user32.dll"")]
    static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, UIntPtr dwExtraInfo);

    [DllImport(""user32.dll"")]
    static extern bool SetCursorPos(int X, int Y);

    [DllImport(""user32.dll"")]
    static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);

    const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    const uint MOUSEEVENTF_LEFTUP = 0x0004;
    const uint MOUSEEVENTF_RIGHTDOWN = 0x0008;
    const uint MOUSEEVENTF_RIGHTUP = 0x0010;
    const uint MOUSEEVENTF_MIDDLEDOWN = 0x0020;
    const uint MOUSEEVENTF_MIDDLEUP = 0x0040;
    const uint MOUSEEVENTF_WHEEL = 0x0800;
    const uint KEYEVENTF_KEYUP = 0x0002;

    public void Play(List<TaskEvent> events, PlaybackSettings settings)
    {{
        int loops = settings.RunUntilStop ? 999 : (settings.Loop ? 999 : 1);

        for (int loop = 0; loop < loops; loop++)
        {{
            for (int i = 0; i < events.Count; i++)
            {{
                var evt = events[i];

                if (i > 0)
                {{
                    double delay = (evt.Timestamp - events[i - 1].Timestamp) / settings.Speed * 1000;
                    if (delay > 0) Thread.Sleep((int)delay);
                }}

                ExecuteEvent(evt);
            }}

            if (!settings.Loop && !settings.RunUntilStop) break;
        }}
    }}

    void ExecuteEvent(TaskEvent evt)
    {{
        switch (evt.Type)
        {{
            case ""mouse_move"":
                SetCursorPos(evt.X, evt.Y);
                break;

            case ""mouse_click"":
                SetCursorPos(evt.X, evt.Y);
                string btn = evt.Button?.ToLower() ?? ""left"";
                
                if (evt.Pressed)
                {{
                    if (btn.Contains(""left"")) mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, UIntPtr.Zero);
                    else if (btn.Contains(""right"")) mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, UIntPtr.Zero);
                    else if (btn.Contains(""middle"")) mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0, UIntPtr.Zero);
                }}
                else
                {{
                    if (btn.Contains(""left"")) mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, UIntPtr.Zero);
                    else if (btn.Contains(""right"")) mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, UIntPtr.Zero);
                    else if (btn.Contains(""middle"")) mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0, UIntPtr.Zero);
                }}
                break;

            case ""mouse_scroll"":
                mouse_event(MOUSEEVENTF_WHEEL, 0, 0, (uint)(evt.Dy * 100), UIntPtr.Zero);
                break;

            case ""key_press"":
                SendKey(evt.Key, false);
                break;

            case ""key_release"":
                SendKey(evt.Key, true);
                break;
        }}
    }}

    void SendKey(string keyName, bool release)
    {{
        if (string.IsNullOrEmpty(keyName)) return;
        // Simplified key sending - extend as needed
        byte vk = (byte)Enum.Parse(typeof(Keys), keyName, true);
        keybd_event(vk, 0, release ? KEYEVENTF_KEYUP : 0, UIntPtr.Zero);
    }}
}}
";
        }

        private static string GenerateRunnerCsproj(string taskName)
        {
            return $@"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net6.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <AssemblyName>{taskName}</AssemblyName>
    <PublishSingleFile>true</PublishSingleFile>
    <SelfContained>true</SelfContained>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <PublishTrimmed>false</PublishTrimmed>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""Newtonsoft.Json"" Version=""13.0.3"" />
  </ItemGroup>
</Project>";
        }

        private static void WriteLogFile(string logPath, TaskData taskData)
        {
            var log = new StringBuilder();
            log.AppendLine($"Task: {taskData.Name}");
            log.AppendLine($"Version: {taskData.Version}");
            log.AppendLine($"Created: {taskData.Created}");
            log.AppendLine($"Events: {taskData.Events.Count}");
            log.AppendLine();
            log.AppendLine("Playback Settings:");
            log.AppendLine($"  Speed: {taskData.Playback.Speed}x");
            log.AppendLine($"  Loop: {taskData.Playback.Loop}");
            log.AppendLine($"  Run Until Stop: {taskData.Playback.RunUntilStop}");
            
            if (taskData.Schedule.Enabled)
            {
                log.AppendLine();
                log.AppendLine("Schedule:");
                log.AppendLine($"  Days: {string.Join("", "", taskData.Schedule.Days)}");
                log.AppendLine($"  Time: {taskData.Schedule.TimeFrom} - {taskData.Schedule.TimeTo}");
            }

            File.WriteAllText(logPath, log.ToString(), Encoding.UTF8);
        }
    }
}

